#pragma once

/* Реализуйте шаблонную функцию Copy, которая принимает три указателя: 
- src_begin - указатель на начало первой последовательности, 
- src_end - указатель на конец первой последовательности, 
- dest - указатель на начало второй последовательности. 
Функция копирует содержимое первой последовательности во вторую и возвращает указатель на конец второй последовательности.

Также реализуйте функцию CopyBackward, которая делает то же, что и Copy, но третьим параметром принимает конец второй последовательности 
и при копировании проходит по элементам первой последовательности в обратном порядке (порядок при этом должен остаться прямым). 
Вернуть следует последний скопированный элемент второй последовательности.*/


// Когда использовать: Когда диапазоны не пересекаются или dest начинается до src_end, порядок копирования прямой. 
// Например, обычное копирование элементов из одного массива в другой
template <typename T, typename U>
U* Copy(T* src_begin, T* src_end, U* dest){
    auto current_src = src_begin;
    auto current_dest = dest;

    while (current_src != src_end) {
        *current_dest = *current_src;
        ++current_src;
        ++current_dest;
    }
    return current_dest;
}

// Когда использовать: Когда целевой диапазон перекрывается с исходным, особенно сдвиг элементов вправо внутри одного массива.
// Например, смещение части массива без потери данных.
template <typename T, typename U>
U* CopyBackward(const T* src_begin, const T* src_end, U* dest_end) {
    auto current_src = src_end - 1;
    auto current_dest = dest_end - 1;

    while (current_src >= src_begin) {
        *current_dest = *current_src;
        --current_src;
        --current_dest;
    }
    return dest_end;
}
